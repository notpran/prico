"use strict";
var g = Object.create;
var d = Object.defineProperty;
var D = Object.getOwnPropertyDescriptor;
var S = Object.getOwnPropertyNames;
var b = Object.getPrototypeOf, P = Object.prototype.hasOwnProperty;
var k = (n, i) => {
  for (var e in i)
    d(n, e, { get: i[e], enumerable: !0 });
}, w = (n, i, e, t) => {
  if (i && typeof i == "object" || typeof i == "function")
    for (let s of S(i))
      !P.call(n, s) && s !== e && d(n, s, { get: () => i[s], enumerable: !(t = D(i, s)) || t.enumerable });
  return n;
};
var u = (n, i, e) => (e = n != null ? g(b(n)) : {}, w(
  i || !n || !n.__esModule ? d(e, "default", { value: n, enumerable: !0 }) : e,
  n
)), C = (n) => w(d({}, "__esModule", { value: !0 }), n);

// src/server/index.ts
var _ = {};
k(_, {
  Document: () => p,
  YSocketIO: () => y
});
module.exports = C(_);

// src/server/document.ts
var v = u(require("yjs")), h = u(require("y-protocols/awareness")), Y = process.env.GC !== "false" && process.env.GC !== "0", p = class extends v.Doc {
  constructor(e, t, s) {
    super({ gc: Y });
    this.onUpdateDoc = (e) => {
      var t;
      if (((t = this.callbacks) == null ? void 0 : t.onUpdate) != null)
        try {
          this.callbacks.onUpdate(this, e);
        } catch (s) {
          console.warn(s);
        }
      this.namespace.emit("sync-update", e);
    };
    this.onUpdateAwareness = ({ added: e, updated: t, removed: s }, a) => {
      var c;
      let l = e.concat(t, s), r = h.encodeAwarenessUpdate(this.awareness, l);
      if (((c = this.callbacks) == null ? void 0 : c.onChangeAwareness) != null)
        try {
          this.callbacks.onChangeAwareness(this, r);
        } catch (U) {
          console.warn(U);
        }
      this.namespace.emit("awareness-update", r);
    };
    this.name = e, this.namespace = t, this.awareness = new h.Awareness(this), this.awareness.setLocalState(null), this.callbacks = s, this.awareness.on("update", this.onUpdateAwareness), this.on("update", this.onUpdateDoc);
  }
  async destroy() {
    var e;
    if (((e = this.callbacks) == null ? void 0 : e.onDestroy) != null)
      try {
        await this.callbacks.onDestroy(this);
      } catch (t) {
        console.warn(t);
      }
    this.awareness.off("update", this.onUpdateAwareness), this.off("update", this.onUpdateDoc), this.namespace.disconnectSockets(), super.destroy();
  }
};

// src/server/y-socket-io.ts
var o = u(require("yjs")), m = u(require("y-protocols/awareness")), A = require("y-leveldb");
var f = require("lib0/observable"), y = class extends f.Observable {
  constructor(e, t) {
    var s;
    super();
    this._documents = /* @__PURE__ */ new Map();
    this._levelPersistenceDir = null;
    this.persistence = null;
    this.nsp = null;
    this.initSyncListeners = (e, t) => {
      e.on("sync-step-1", (s, a) => {
        a(o.encodeStateAsUpdate(t, new Uint8Array(s)));
      }), e.on("sync-update", (s) => {
        o.applyUpdate(t, s, null);
      });
    };
    this.initAwarenessListeners = (e, t) => {
      e.on("awareness-update", (s) => {
        m.applyAwarenessUpdate(t.awareness, new Uint8Array(s), e);
      });
    };
    this.initSocketListeners = (e, t) => {
      e.on("disconnect", async () => {
        (await e.nsp.allSockets()).size === 0 && (this.emit("all-document-connections-closed", [t]), this.persistence != null && (await this.persistence.writeState(t.name, t), await t.destroy()));
      });
    };
    this.startSynchronization = (e, t) => {
      e.emit("sync-step-1", o.encodeStateVector(t), (s) => {
        o.applyUpdate(t, new Uint8Array(s), this);
      }), e.emit("awareness-update", m.encodeAwarenessUpdate(t.awareness, Array.from(t.awareness.getStates().keys())));
    };
    this.io = e, this._levelPersistenceDir = (s = t == null ? void 0 : t.levelPersistenceDir) != null ? s : process.env.YPERSISTENCE, this._levelPersistenceDir != null && this.initLevelDB(this._levelPersistenceDir), this.configuration = t;
  }
  initialize() {
    this.nsp = this.io.of(/^\/yjs\|.*$/), this.nsp.use(async (e, t) => {
      var s;
      return ((s = this.configuration) == null ? void 0 : s.authenticate) == null || await this.configuration.authenticate(e.handshake) ? t() : t(new Error("Unauthorized"));
    }), this.nsp.on("connection", async (e) => {
      var a;
      let t = e.nsp.name.replace(/\/yjs\|/, ""), s = await this.initDocument(t, e.nsp, (a = this.configuration) == null ? void 0 : a.gcEnabled);
      this.initSyncListeners(e, s), this.initAwarenessListeners(e, s), this.initSocketListeners(e, s), this.startSynchronization(e, s);
    });
  }
  get documents() {
    return this._documents;
  }
  async initDocument(e, t, s = !0) {
    var l;
    let a = (l = this._documents.get(e)) != null ? l : new p(e, t, {
      onUpdate: (r, c) => this.emit("document-update", [r, c]),
      onChangeAwareness: (r, c) => this.emit("awareness-update", [r, c]),
      onDestroy: async (r) => {
        this._documents.delete(r.name), this.emit("document-destroy", [r]);
      }
    });
    return a.gc = s, this._documents.has(e) || (this.persistence != null && await this.persistence.bindState(e, a), this._documents.set(e, a), this.emit("document-loaded", [a])), a;
  }
  initLevelDB(e) {
    let t = new A.LeveldbPersistence(e);
    this.persistence = {
      provider: t,
      bindState: async (s, a) => {
        let l = await t.getYDoc(s), r = o.encodeStateAsUpdate(a);
        await t.storeUpdate(s, r), o.applyUpdate(a, o.encodeStateAsUpdate(l)), a.on("update", async (c) => await t.storeUpdate(s, c));
      },
      writeState: async (s, a) => {
      }
    };
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Document,
  YSocketIO
});
//# sourceMappingURL=index.js.map